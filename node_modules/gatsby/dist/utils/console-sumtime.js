"use strict";

exports.__esModule = true;
exports.default = getData;

/**
 *
 * console.sumTime
 *
 * Note: this script extends the global `console` object with a few methods intended to collect timing
 * information or other counts based on a key. It's basic usage is very similar to `console.time()` and
 * `console.timeEnd()`, except it accumulates and requires you to explicitly trigger the printing part.
 *
 * The idea of these tools is to easily collect timing information on particular function calls or certain
 * lines of code. This is a debugging-only tool that should be a noop if not used.
 *
 * Beware that this tool can not account and compensate for async time spent elsewhere
 *
 * API:
 *
 * - console.sumTime(key: string, callback?: (): any): void
 *   - Similar to console.time, you have to pass the same string to stop this timer after which the delta
 *     of the time will be added to the entry for that key.
 *   - It is also possible to time a function by passing it as a second argument. In that case the function
 *     is called and timed until it yields.
 *
 * - console.sumTimeEnd(key: string, altKey?: string): void
 *   - The running timer by key is stopped and the entry for the key is updated by the time delta taken.
 *   - If the second parameter is given, an entry by that key is updated instead (useful for dynamics).
 *
 * - console.sumTimeGroup(key: string, callback: (): any): void
 *   - Similar to console.group, will call console.sumTime with the same args and automatically increase
 *     the key indentation by two spaces.
 *   - It does not call console.group (!)
 *
 * - console.sumTimeGroupEnd(key: string, altKey: string): undefined
 *   - Similar to console.groupEnd, calls console.sumTimeGroupEnd with same args
 *   - Does not call console.groupEnd (!)
 *
 * - console.sumTimeCancel(key: string): undefined
 *   - Stops the running timer by given key and ignores its time delta
 *
 * - console.sumTimePrint(): undefined
 *   - Dumps the accumulated data to console (through console.log and console.group)
 *
 * - console.sumTimeReset(): undefined
 *   - Clears the accumulated data and keys
 *
 * - console.sumTimeCount(key: string, delta: number = 1): undefined
 *   - Increment the tracked amount of given key by given delta
 *   - If a key exists but was never updated by sumTime then it is printed without `ms` suffix
 *
 */
const {
  performance
} = require(`perf_hooks`);

global.console.log(`[main] Attaching to console now...`);
const console = global.console.sumTime ? {} : global.console;
let running = new Map();
let data = new Map();
let indent = 0;

function _sumTime(name, callback) {
  if (running.has(name)) {
    return console.warn(`console.sumTime: name already being recorded:`, name);
  }

  const now = performance.now();
  running.set(` `.repeat(indent) + name, now);

  if (callback) {
    try {
      callback();
    } finally {
      console.sumTimeEnd(` `.repeat(indent) + name);
    }
  }
}

console.sumTime = _sumTime;

function _sumTimeEnd(name, recordAs = name) {
  const endTime = performance.now();
  const indentedName = ` `.repeat(indent) + name;
  const indentedRecordAs = ` `.repeat(indent) + recordAs;
  const start = running.get(indentedName);

  if (start === undefined) {
    return console.warn(`console.sumTimeEnd: name not being recorded:`, name);
  }

  running.delete(indentedName);
  add(indentedRecordAs, endTime - start, true);
}

console.sumTimeEnd = _sumTimeEnd;

function _sumTimeGroup(name, callback) {
  _sumTime(name, callback);

  indent += 2;
}

console.sumTimeGroup = _sumTimeGroup;

function _sumTimeGroupEnd(name, recordAs = name) {
  indent -= 2;

  _sumTimeEnd(name, recordAs);
}

console.sumTimeGroupEnd = _sumTimeGroupEnd;

function _sumTimeCancel(name) {
  // Should this warn if the name does not exist..?
  running.delete(name);
}

console.sumTimeCancel = _sumTimeCancel;

function _sumTimePrint() {
  // console.log(data)
  console.group(`sumTime report;`);
  let maxs = 0;
  let maxc = 0;
  data.forEach(({
    sum,
    count
  }, _name) => {
    const whole = Math.floor(sum).toString();
    maxs = Math.max(maxs, whole.length);
    maxc = Math.max(maxc, String(count).length);
  });
  const arr = [];
  data.forEach(({
    sum,
    count,
    isTimer
  }, name) => {
    const whole = Math.floor(sum).toString();
    const rest = String(sum % 1).slice(1); // Either zero or `0.` plus fraction

    arr.push(`- ` + (isTimer ? whole.padStart(maxs, ` `) + rest.slice(0, 3).padEnd(3, ` `) + `ms` : (whole.padStart(maxs, ` `) + (sum === count ? rest + ` x` : rest.padEnd(3, ` `))).padEnd(maxs + 5, ` `)) + (isTimer || count !== sum ? ` (` + count.toString().padStart(maxc + 1, ` `) + `x )` : ` `.repeat(maxc + 6)) + `: ` + name);
  });
  console.log(arr.reverse().join(`\n`));
  console.groupEnd();
}

console.sumTimePrint = _sumTimePrint;

function _sumTimeClear() {
  data = new Map();
  running = new Map();
  indent = 0;
}

console.sumTimeReset = _sumTimeClear;

function _sumTimeCount(name, delta = 1) {
  add(name, delta, false);
}

console.sumTimeCount = _sumTimeCount;

function add(name, delta, isTimer) {
  let obj = data.get(name);

  if (obj === undefined) {
    obj = {
      sum: 0,
      count: 0,
      isTimer
    };
    data.set(name, obj);
  }

  obj.sum += delta;
  obj.isTimer = isTimer;
  ++obj.count;
}

function getData() {
  return data;
}
//# sourceMappingURL=console-sumtime.js.map